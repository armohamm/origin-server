#!/usr/bin/env ruby

require 'rubygems'
require 'getoptlong'
require 'json'
require 'yaml'

def usage
    puts <<USAGE
== Synopsis

ss-admin-ctl-template: Add or remove an application template

== Usage

ss-admin-ctl-template OPTIONS

Options:
-u|--uuid UUID
  The UUID of the application template to remove.
-n|--named NAME
  The display name of the template
-a|--all
  Run command against all templates (only works for remove)
-c|--command <command>
    (add|remove) (required)
-d|--descriptor DESCRIPTOR
  The descriptor as YAML or a file path to the descriptor
-g|--git-url GIT_URL
  The URL to the git repository holding the source code for this template
-t|--tags TAGS
  Comma seperated list of tags for the template
--cost GEAR_COST
  The number of gears this template will use
-m|--metadata
  The JSON metadata for this template or a file path to the JSON metadata
-h|--help
    Show Usage info

UUID and Named options can be comma separated lists for remove command
USAGE
end

opts = GetoptLong.new(
    ["--uuid",             "-u", GetoptLong::REQUIRED_ARGUMENT],    
    ["--named",            "-n", GetoptLong::REQUIRED_ARGUMENT],
    ["--all",              "-a", GetoptLong::NO_ARGUMENT],
    ["--command",          "-c", GetoptLong::REQUIRED_ARGUMENT],
    ["--descriptor",       "-d", GetoptLong::REQUIRED_ARGUMENT],
    ["--git-url",          "-g", GetoptLong::REQUIRED_ARGUMENT],
    ["--tags",             "-t", GetoptLong::REQUIRED_ARGUMENT],
    ["--cost",                   GetoptLong::REQUIRED_ARGUMENT],
    ["--metadata",         "-m", GetoptLong::REQUIRED_ARGUMENT],    
    ["--help",             "-h", GetoptLong::NO_ARGUMENT]
)

args = {}
begin
    opts.each{ |k,v| args[k]=v }
rescue GetoptLong::Error => e
    usage
    exit -100
end

uuid             = args["--uuid"]
display_name     = args["--named"]
all              = args["--all"]
command          = args['--command']
descriptor       = args["--descriptor"]
git_url          = args["--git-url"]
tags             = args["--tags"]
gear_cost        = args["--cost"]
metadata         = args["--metadata"]

if args["--help"]
  usage
  exit 1
end

require "/var/www/stickshift/broker/config/boot"
require "/var/www/stickshift/broker/config/environment"
require "/var/www/stickshift/broker/config/application"
Rails.application.require_environment!

case command
when "add"
  if display_name.split(',').length > 1
    print "Can only use multiple names with remove\n"
    usage
    exit -100
  end

  begin
    descriptor = File.file?(descriptor) ?
      YAML.load_file(descriptor) :
      YAML.load(descriptor)
    raise unless descriptor.kind_of?(Hash)
  rescue Exception => e
    print "Invalid descriptor YAML: #{descriptor}\n"
    usage
    exit -100
  end

  begin
    metadata = File.file?(metadata) ?
      JSON.load(File.open(metadata)) :
      JSON.parse(metadata)
    raise unless metadata.kind_of?(Hash)
  rescue Exception => e
    print "Invalid metadata JSON: #{metadata}\n"
    usage
    exit -100
  end

  tags = "" if tags.nil?
  tags = tags.split(",")
  
  template = ApplicationTemplate.new(display_name: display_name, descriptor_yaml: descriptor.to_yaml, git_url: git_url, tags: tags, gear_cost: gear_cost, template_metadata: metadata)
  template.save
  print "Template #{template.id.to_s} created\n"

when "remove"
  # Make sure at least one of these is selected
  msg = case
        when [uuid,display_name].compact.empty?
          "Must provide either a template name or UUID (or both)\n" unless all
        when all
          "Cannot provide --all if you also provide UUIDs or names\n"
        end
  if msg
    print msg
    usage
    exit -100
  end

  # Retrieve all templates
  results = []

  # Don't filter if we're deleting all templates
  if all
    results = ApplicationTemplate.all
  else
    unless uuid.nil? or uuid.empty?
      uuid.split(",").each do |u|
        begin
          results << ApplicationTemplate.find(u)
        rescue Mongoid::Errors::DocumentNotFound
          print "Unable to find template by UUID #{u}\n"
        end
      end
    end
    
    unless display_name.nil? or display_name.empty?
      match_count = ApplicationTemplate.where(display_name: display_name).count
      if match_count == 0
        print "Display name #{display_name} did not match any templates. \nPossible alternatives:\n"
        ApplicationTemplate.where(display_name: /#{display_name}/i).each do |t|
          print "- #{t.id}: #{t.display_name}\n"
        end
        exit(-1)
      elsif match_count > 1
        print "Display name #{display_name} matches multiple templates. \nPlease specify UUID:\n"
        ApplicationTemplate.where(display_name: display_name).each do |t|
          print "- #{t.id}: #{t.display_name}\n"
        end
        exit(-1)
      else
        results << ApplicationTemplate.find_by(display_name: display_name)
      end
    end
  end

  # Loop through all results and attempt to delete
  # TODO: Figure out how delete can fail or if it returns any information
  results.each do |template|
    begin
      template.delete
      result = "(%s) deleted" % template.id.to_s
    rescue
      result = "deletion FAILED"
    end
    print "'#{template.display_name}' template %s\n" % result
  end
else
  print "Command must be one of: (add|remove)"
  usage
  exit -100
end
